##### Java 虚拟机 内存管理

相关问题：

- 分配内存的最小单位是？

- 一个进程有3个线程，如果一个线程抛出oom，其他两个线程还能运行么?

---

![avatar](https://github.com/lknlll/LinDroid/raw/LinDroid/blog/pic/JVMMemery.png)

###### JVM中的 进程和线程

进程是资源分配的最小单位，线程是程序执行的最小单位。

进程有自己的独立地址空间，每启动一个进程，系统就会为它分配一个地址空间、建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间

一个进程至少包含一个线程。线程之间的通信更加方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信则需要以通信的方式（IPC）进行

方法区和堆分配给进程，作为线程共享区；栈和程序计数器分配给每个独立线程。

###### Java Virtual Machine Stack 虚拟机栈区

线程私有 生命周期和线程相同

JVM栈记录了线程的方法调用，每个线程一个栈，在某个线程的运行过程中，如果有新的方法调用，那么该线程对应的栈就会增加一个存储单元，即栈针（Stack Frame）

虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行时都会创建一个栈针（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。
每一个方法从调用至完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程

存放的为当前线程中局部基本类型的变量（java中定义的八种基本类型：boolean、char、byte、short、int、long、float、double）、部分的返回结果以及Stack Frame，

非基本类型的对象在JVM栈上仅存放一个指向堆上的地址，因此Java中基本类型的变量是值传递，而非基本类型的变量是引用传递

###### Native Method Stack native方法栈

Java虚拟机栈是位虚拟机执行Java方法（也就是字节码）服务，而本地方法栈为位虚拟机使用到的Native方法服务。

###### Java Heap 堆

被所有线程共享的一块数据区域，在虚拟机启动时创建，这一内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存

GC的主要区域；

---

OOM 是JVM 的一种自我防御机制，用于防止整个应用程序崩溃，OOM线程会被Kill掉，然后抛出OutOfMemory异常信息。

如果是栈溢出，因为栈上的空间是线程私有的，所以线程被Kill掉之后，栈上的空间就被释放了，不影响别的线程；

如果是堆溢出，虽然堆空间是共享的，但OOM时在堆中申请空间导致此次OOM的线程会被Kill，保证进程安全；

但造成OOM的大对象可能被该线程之外的其他线程引用，这个时候这部分对象就没有办法被GC掉，其他线程如果此时需要申请资源但是又资源又不足，有可能导致其他线程不能运行。
