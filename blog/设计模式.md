###### 单一职责原则，Single Responsibility Principle(SRP)

用职责定义类。
###### 开闭原则，Open Close Principle(OCP)：

类、模块或函数，应该对修改关闭，对扩展开放。

###### 依赖倒置原则
可以理解为面向接口；

1. 高层模块不依赖低层，两者依赖其抽象。
2. 抽象不依赖细节
3. 细节依赖抽象


例如，图片加载类，可能会包括从内存加载，从硬盘加载等


```
//内存缓存类 没有依赖抽象或接口的底层类
public class MemoryCache{
    //图片LRU缓存
    private LruCache<String,Bitmap> mMemoryCache;
    public ImageCache(){
       //初始化内存
    }

    //缓存图片
    public void put(String url,Bitmap bitmap){
      mImageCache.put(url,bitmap);
    } 
    //获取图片
    public Bitmap get(String url){
      return mImageCache.get(url);
    }  
}

//图片加载类 高层模块，调用类
class ImageLoader{
   //内存缓存
   MemoryCache mImageCache = new MemoryCache();

  //ImageView 显示图片
   public void display(String url,ImageView imageView){
       //加载图片的具体细节略去，那不是重点。。。
       imageView.setImageBitmap(mImageCache.get(url));
   }
}
```


首先要声明一个接口，定义所有的图片加载需要实现的方法（也就是所谓行为），低层具体实现这些行为，高层调用依赖的接口的方法实现功能；

```
//图片缓存接口声明
public interface ImageCache{
   /**
    * 获取图片
    */
   public Bitmap get(String url);
   /**
    * 缓存图片
    */
   public void put(String url,Bitmap bitmap);
}
```
将所有内存加载类实现ImageCache接口。当业务实例中使用时根据需要传入ImageCache的具体实现即可，当扩展新的方式时不需修改原有方式。
```
//内存缓存类 实现 ImageCache 接口
public class MemoryCache implements ImageCache{
    //图片LRU缓存
    private LruCache<String,Bitmap> mMemoryCache;
    public ImageCache(){
       //初始化内存
    }
    
    //缓存图片
    @Override
    public void put(String url,Bitmap bitmap){
      mImageCache.put(url,bitmap);
    } 
    //缓存图片
    @Override
    public Bitmap get(String url){
      mImageCache.get(url);
    }    
}

//SD卡缓存类 实现 ImageCache 接口
public class DiskCache implements ImageCache{
    
    //缓存图片
    @Override
    public void put(String url,Bitmap bitmap){
     //将图片存入本地文件中
     ...
    } 
    //缓存图片
    @Override
    public Bitmap get(String url){
      //根据url从本地读取图片
      ...
    }    
}
```
###### 迪米特原则（最小知识原则）

一个对象应该对其他对象有最小的了解，高内聚，低耦合。